<!DOCTYPE html>
<html>

<head>
    <title>Bulb Sequence Editor</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
        }

        .color-preview {
            width: 40px;
            height: 40px;
            display: inline-block;
            border: 1px solid #ccc;
            margin-right: 8px;
            vertical-align: middle;
        }
    </style>
    <script src="/iro.min.js"></script>
</head>

<body>
        <h2>Bulb Sequence Editor</h2>
        <div style="margin-bottom:1em; padding:0.5em; background:#f8f8f8; border-radius:6px; border:1px solid #ddd; display:flex; align-items:center; gap:0.5em;">
            <label style="font-weight:bold;"><input type="checkbox" id="liveSyncCheckbox"> Live Bulb Sync</label>
            <span id="playControls" style="display:none;">
                <button id="playSequenceBtn" type="button">Play</button>
                <button id="nextStepBtn" type="button" style="display:none;">Next Step</button>
            </span>
            <button type="button" id="bulbOnBtn">Turn Bulb On</button>
            <button type="button" id="bulbOffBtn">Turn Bulb Off</button>
            <span id="bulbStatus" style="margin-left:1em; font-weight:bold;"></span>
        </div>
    <button id="toggleJsonBtn" type="button" onclick="toggleJson()">Show Advanced JSON Editor</button>
    <div id="jsonEditor" style="display:none; margin-top:1em;">
        <form id="seqForm">
            <label>Paste Sequence JSON:<br>
                <textarea id="seqJson" rows="8" cols="60"></textarea>
            </label><br><br>
            <button type="button" onclick="parseSequence()">Parse & Visualize</button>
        </form>
    </div>
    <div id="manualEntry">
        <h3>Manual Entry</h3>
        <button type="button" onclick="addStep()">Add Step</button>
        <div id="steps"></div>
    </div>
    <div id="colorPickerModal"
        style="display:none; position:fixed; top:10%; left:50%; transform:translateX(-50%); background:#fff; border:1px solid #ccc; padding:20px; z-index:1000;">
        <div id="colorPicker"></div>
        <div style="margin-top:1em;">
            <button id="applyColorBtn">Apply</button>
            <button id="cancelColorBtn">Cancel</button>
        </div>
    </div>
    <hr>
    <label>Start Time: <input type="time" id="startTime"></label>
    <label>Duration (minutes): <input type="number" id="duration" min="1" value="60"></label>
    <br><br>
    <button onclick="saveSequence()">Save Sequence to KV</button>
    <div id="result"></div>
    <script>
                        // Show/hide play controls based on Live Bulb Sync
                        function updatePlayControlsVisibility() {
                            const playControls = document.getElementById('playControls');
                            const liveSyncCheckbox = document.getElementById('liveSyncCheckbox');
                            if (liveSyncCheckbox && playControls) {
                                playControls.style.display = liveSyncCheckbox.checked ? '' : 'none';
                            }
                        }
                        updatePlayControlsVisibility();
                        document.getElementById('liveSyncCheckbox').addEventListener('change', updatePlayControlsVisibility);
                let playingStepIdx = null;

                function highlightStep(idx) {
                    document.querySelectorAll('#steps > div').forEach((el, i) => {
                        el.style.background = (i === idx) ? '#ffe066' : '';
                    });
                }

                async function playStep(idx) {
                    if (idx < 0 || idx >= sequence.length) return;
                    playingStepIdx = idx;
                    highlightStep(idx);
                    const step = sequence[idx];
                    // Only update bulb if live sync is enabled
                    if (window.liveSyncEnabled) {
                        if (step.work_mode === 'white') {
                            await fetch('/bulb/color', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    work_mode: 'white',
                                    brightness: step.brightness,
                                    temperature: step.temperature
                                })
                            });
                        } else {
                            await fetch('/bulb/color', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    hue: step.hue,
                                    saturation: step.saturation,
                                    brightness: step.brightness
                                })
                            });
                        }
                    }
                }

                function resetPlaySequence() {
                    playingStepIdx = null;
                    highlightStep(-1);
                    document.getElementById('playSequenceBtn').style.display = '';
                    document.getElementById('nextStepBtn').style.display = 'none';
                }

                document.getElementById('playSequenceBtn').addEventListener('click', async () => {
                    if (!sequence.length) return;
                    await playStep(0);
                    document.getElementById('playSequenceBtn').style.display = 'none';
                    document.getElementById('nextStepBtn').style.display = '';
                });
                document.getElementById('nextStepBtn').addEventListener('click', async () => {
                    if (playingStepIdx === null) return;
                    if (playingStepIdx < sequence.length - 1) {
                        await playStep(playingStepIdx + 1);
                    } else {
                        resetPlaySequence();
                    }
                });

                // Unhighlight steps if sequence changes
                const origRenderSteps = renderSteps;
                renderSteps = function() {
                    origRenderSteps();
                    if (playingStepIdx !== null) highlightStep(playingStepIdx);
                }
        // Update step times when start time or duration changes
        window.addEventListener('DOMContentLoaded', () => {
            // Only declare liveSyncCheckbox once
            window.liveSyncEnabled = document.getElementById('liveSyncCheckbox').checked;
            console.log('Live Bulb Sync initial:', window.liveSyncEnabled);
            document.getElementById('liveSyncCheckbox').addEventListener('change', function() {
                window.liveSyncEnabled = this.checked;
                console.log('Live Bulb Sync toggled:', window.liveSyncEnabled);
            });
            document.getElementById('startTime').addEventListener('input', renderSteps);
            document.getElementById('duration').addEventListener('input', renderSteps);

            // Bulb on/off button logic
            const bulbStatus = document.getElementById('bulbStatus');
            document.getElementById('bulbOnBtn').addEventListener('click', async () => {
                bulbStatus.textContent = 'Turning bulb ON...';
                try {
                    const res = await fetch('/bulb/power', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ on: true })
                    });
                    const text = await res.text();
                    bulbStatus.textContent = text;
                } catch (e) {
                    bulbStatus.textContent = 'Error turning bulb on';
                }
            });
            document.getElementById('bulbOffBtn').addEventListener('click', async () => {
                bulbStatus.textContent = 'Turning bulb OFF...';
                try {
                    const res = await fetch('/bulb/power', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ on: false })
                    });
                    const text = await res.text();
                    bulbStatus.textContent = text;
                } catch (e) {
                    bulbStatus.textContent = 'Error turning bulb off';
                }
            });
        });
        // Track which white step is being edited with sliders
        let whiteSliderStep = null;
        function toggleJson() {
            const editor = document.getElementById('jsonEditor');
            const btn = document.getElementById('toggleJsonBtn');
            if (editor.style.display === 'none') {
                editor.style.display = '';
                btn.textContent = 'Hide Advanced JSON Editor';
            } else {
                editor.style.display = 'none';
                btn.textContent = 'Show Advanced JSON Editor';
            }
        }

        window.toggleJson = toggleJson;
        let sequence = [];
        let currentColorStep = null;
        // Load sequence:morning from KV on page load
        window.addEventListener('DOMContentLoaded', async () => {
            // Wait for iro.js to be loaded before rendering steps
            function waitForIroJs(cb) {
                if (window.iro && window.iro.Color) {
                    cb();
                } else {
                    setTimeout(() => waitForIroJs(cb), 30);
                }
            }
            try {
                const res = await fetch('/get-sequence');
                if (res.ok) {
                    const seq = await res.json();
                    if (seq && seq.steps) {
                        sequence = seq.steps;
                        document.getElementById('seqJson').value = JSON.stringify(seq, null, 2);
                        document.getElementById('startTime').value = seq.startTime || '';
                        document.getElementById('duration').value = seq.duration || 60;
                        waitForIroJs(renderSteps);
                        return;
                    }
                }
            } catch (e) {
                // Ignore load errors
            }
            waitForIroJs(renderSteps);
        });
        function parseSequence() {
            try {
                sequence = JSON.parse(document.getElementById('seqJson').value).steps || [];
                renderSteps();
            } catch (e) {
                alert('Invalid JSON');
            }
        }
        function addStep() {
            sequence.push({ work_mode: 'colour', hue: 0, saturation: 0, brightness: 0, on: true });
            renderSteps();
        }
        function getStepTimes() {
            // Returns an array of time strings for each step
            const startTimeStr = document.getElementById('startTime').value;
            const duration = Number(document.getElementById('duration').value) || 60;
            let times = [];
            if (!startTimeStr || !/^\d{2}:\d{2}$/.test(startTimeStr)) {
                // fallback: show --:--
                for (let i = 0; i < sequence.length; ++i) times.push('--:--');
                return times;
            }
            const [h, m] = startTimeStr.split(':').map(Number);
            let totalMinutes = h * 60 + m;
            for (let i = 0; i < sequence.length; ++i) {
                let stepH = Math.floor(totalMinutes / 60) % 24;
                let stepM = totalMinutes % 60;
                times.push((stepH < 10 ? '0' : '') + stepH + ':' + (stepM < 10 ? '0' : '') + stepM);
                totalMinutes += duration;
            }
            return times;
        }

        function renderSteps() {
            // Sync JSON textarea with current sequence
            const seqJson = document.getElementById('seqJson');
            if (seqJson) {
                const startTime = document.getElementById('startTime').value;
                const duration = document.getElementById('duration').value;
                seqJson.value = JSON.stringify({ steps: sequence, startTime, duration }, null, 2);
            }
            const stepsDiv = document.getElementById('steps');
            stepsDiv.innerHTML = '';
            const stepTimes = getStepTimes();
            sequence.forEach((step, i) => {
                let color = '#fff';
                if (step.work_mode === 'colour') {
                    let h = step.hue || 0;
                    let s = ((step.saturation || 0) / 255) * 100;
                    let v = ((step.brightness || 0) / 255) * 100;
                    if (window.iro && window.iro.Color) {
                        const c = new window.iro.Color({ h, s, v });
                        color = c.hexString;
                    } else {
                        color = hsvToRgb(step.hue, step.saturation, step.brightness);
                    }
                }
                let html = '<div data-index="' + i + '">';
                html += '<span style="font-size:0.95em; color:#555; margin-right:8px; min-width:56px; display:inline-block;">' + stepTimes[i] + '</span>';
                if (step.work_mode === 'colour') {
                    let previewColor = color;
                    if (currentColorStep === i && window.iroPicker) {
                        // Show live preview from picker
                        const c = window.iroPicker.color;
                        previewColor = c.hexString;
                    }
                    html += '<span class="color-preview" style="background:' + previewColor + '; cursor:pointer;" onclick="openColorPicker(' + i + ')"></span>';
                    html += 'Mode: <select class="mode-select" data-index="' + i + '">';
                    html += '<option value="colour"' + (step.work_mode === 'colour' ? ' selected' : '') + '>Colour</option>';
                    html += '<option value="white"' + (step.work_mode === 'white' ? ' selected' : '') + '>White</option>';
                    html += '</select>';
                } else {
                    // Calculate white color based on brightness and temperature
                    let bright = typeof step.brightness === 'number' ? step.brightness : 255;
                    let temp = typeof step.temperature === 'number' ? step.temperature : 255;
                    // Map temp 0 (warm) to 255 (cool) to RGB
                    // Warm: rgb(255, 197, 143), Cool: rgb(201, 226, 255)
                    function tempToRGB(temp, bright) {
                        // Linear interpolation between warm and cool
                        let t = temp / 255;
                        let r = Math.round((1 - t) * 255 + t * 201);
                        let g = Math.round((1 - t) * 197 + t * 226);
                        let b = Math.round((1 - t) * 143 + t * 255);
                        // Scale by brightness
                        let scale = bright / 255;
                        r = Math.round(r * scale);
                        g = Math.round(g * scale);
                        b = Math.round(b * scale);
                        return `rgb(${r},${g},${b})`;
                    }
                    let white = tempToRGB(temp, bright);
                    html += '<span class="color-preview" style="background:' + white + '; margin-right:8px; border:2px solid #888; cursor:pointer;" title="Click to edit with sliders" onclick="showWhiteSliders(' + i + ')"></span>';
                    html += 'Mode: <select class="mode-select" data-index="' + i + '">';
                    html += '<option value="colour"' + (step.work_mode === 'colour' ? ' selected' : '') + '>Colour</option>';
                    html += '<option value="white"' + (step.work_mode === 'white' ? ' selected' : '') + '>White</option>';
                    html += '</select>';
                    if (whiteSliderStep == i) {
                        html += '<div style="display:inline-block; margin-left:10px; vertical-align:middle;">';
                        html += '<label>Brightness: <input type="range" min="0" max="255" class="bright-slider" data-index="' + i + '" value="' + bright + '"></label>';
                        html += '<label style="margin-left:8px;">Temperature: <input type="range" min="0" max="255" class="temp-slider" data-index="' + i + '" value="' + temp + '"></label>';
                        html += '</div>';
                    }
                }
                window.showWhiteSliders = function (i) {
                    whiteSliderStep = Number(i);
                    currentColorStep = null;
                    renderSteps();
                }
                html += ' On: <input type="checkbox" class="on-checkbox" data-index="' + i + '"' + (step.on ? ' checked' : '') + '>';
                html += ' <button class="del-btn" data-index="' + i + '">Delete</button>';
                html += '</div>';
                stepsDiv.innerHTML += html;
            });
            // Add event listeners (event delegation)
            stepsDiv.querySelectorAll('.mode-select').forEach(el => {
                el.onchange = function () {
                    updateStep(this.dataset.index, 'work_mode', this.value);
                    whiteSliderStep = null;
                    // Sync JSON textarea after mode change
                    const seqJson = document.getElementById('seqJson');
                    if (seqJson) {
                        const startTime = document.getElementById('startTime').value;
                        const duration = document.getElementById('duration').value;
                        seqJson.value = JSON.stringify({ steps: sequence, startTime, duration }, null, 2);
                    }
                };
            });
            stepsDiv.querySelectorAll('.hue-input').forEach(el => {
                function sendLiveColor(idx) {
                    console.log('sendLiveColor', idx, sequence[idx], 'liveSyncEnabled:', window.liveSyncEnabled);
                    if (window.liveSyncEnabled) {
                        const step = sequence[idx];
                        if (step.work_mode === 'white') {
                            fetch('/bulb/color', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    work_mode: 'white',
                                    brightness: step.brightness,
                                    temperature: step.temperature
                                })
                            });
                        } else {
                            fetch('/bulb/color', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    hue: step.hue,
                                    saturation: step.saturation,
                                    brightness: step.brightness
                                })
                            });
                        }
                    }
                }
                el.oninput = function () {
                    console.log('hue-input oninput', this.dataset.index, this.value, window.liveSyncEnabled);
                    updateStep(this.dataset.index, 'hue', this.value, true);
                    sendLiveColor(this.dataset.index);
                };
                el.onchange = function () {
                    console.log('hue-input onchange', this.dataset.index, this.value, window.liveSyncEnabled);
                    updateStep(this.dataset.index, 'hue', this.value);
                    sendLiveColor(this.dataset.index);
                };
            });
            stepsDiv.querySelectorAll('.sat-input').forEach(el => {
                el.oninput = function () {
                    console.log('sat-input oninput', this.dataset.index, this.value, liveSyncEnabled);
                    updateStep(this.dataset.index, 'saturation', this.value, true);
                    sendLiveColor(this.dataset.index);
                };
                el.onchange = function () {
                    console.log('sat-input onchange', this.dataset.index, this.value, liveSyncEnabled);
                    updateStep(this.dataset.index, 'saturation', this.value);
                    sendLiveColor(this.dataset.index);
                };
            });
            stepsDiv.querySelectorAll('.bright-input').forEach(el => {
                el.oninput = function () {
                    console.log('bright-input oninput', this.dataset.index, this.value, liveSyncEnabled);
                    updateStep(this.dataset.index, 'brightness', this.value, true);
                    sendLiveColor(this.dataset.index);
                };
                el.onchange = function () {
                    console.log('bright-input onchange', this.dataset.index, this.value, liveSyncEnabled);
                    updateStep(this.dataset.index, 'brightness', this.value);
                    sendLiveColor(this.dataset.index);
                };
            });
            stepsDiv.querySelectorAll('.bright-slider').forEach(el => {
                const idx = el.dataset.index;
                const tempEl = stepsDiv.querySelector('.temp-slider[data-index="' + idx + '"]');
                const preview = stepsDiv.querySelector('div[data-index="' + idx + '"] .color-preview');
                function tempToRGB(temp, bright) {
                    let t = temp / 255;
                    let r = Math.round((1 - t) * 255 + t * 201);
                    let g = Math.round((1 - t) * 197 + t * 226);
                    let b = Math.round((1 - t) * 143 + t * 255);
                    let scale = bright / 255;
                    r = Math.round(r * scale);
                    g = Math.round(g * scale);
                    b = Math.round(b * scale);
                    return `rgb(${r},${g},${b})`;
                }
                el.oninput = function () {
                    sequence[idx].brightness = Number(this.value);
                    if (preview && tempEl) preview.style.background = tempToRGB(Number(tempEl.value), Number(this.value));
                    console.log('white bright-slider oninput', idx, this.value, liveSyncEnabled);
                    if (liveSyncEnabled) {
                        const step = sequence[idx];
                        fetch('/bulb/color', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                work_mode: 'white',
                                brightness: step.brightness,
                                temperature: step.temperature || 255
                            })
                        });
                    }
                };
                el.onchange = function () {
                    renderSteps();
                    console.log('white bright-slider onchange', idx, this.value, liveSyncEnabled);
                    if (liveSyncEnabled) {
                        const step = sequence[idx];
                        fetch('/bulb/color', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                work_mode: 'white',
                                brightness: step.brightness,
                                temperature: step.temperature || 255
                            })
                        });
                    }
                };
            });
            stepsDiv.querySelectorAll('.temp-slider').forEach(el => {
                const idx = el.dataset.index;
                const brightEl = stepsDiv.querySelector('.bright-slider[data-index="' + idx + '"]');
                const preview = stepsDiv.querySelector('div[data-index="' + idx + '"] .color-preview');
                function tempToRGB(temp, bright) {
                    let t = temp / 255;
                    let r = Math.round((1 - t) * 255 + t * 201);
                    let g = Math.round((1 - t) * 197 + t * 226);
                    let b = Math.round((1 - t) * 143 + t * 255);
                    let scale = bright / 255;
                    r = Math.round(r * scale);
                    g = Math.round(g * scale);
                    b = Math.round(b * scale);
                    return `rgb(${r},${g},${b})`;
                }
                el.oninput = function () {
                    sequence[idx].temperature = Number(this.value);
                    if (preview && brightEl) preview.style.background = tempToRGB(Number(this.value), Number(brightEl.value));
                    console.log('white temp-slider oninput', idx, this.value, liveSyncEnabled);
                    if (liveSyncEnabled) {
                        const step = sequence[idx];
                        fetch('/bulb/color', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                work_mode: 'white',
                                brightness: step.brightness,
                                temperature: step.temperature
                            })
                        });
                    }
                };
                el.onchange = function () {
                    renderSteps();
                    console.log('white temp-slider onchange', idx, this.value, liveSyncEnabled);
                    if (liveSyncEnabled) {
                        const step = sequence[idx];
                        fetch('/bulb/color', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                work_mode: 'white',
                                brightness: step.brightness,
                                temperature: step.temperature
                            })
                        });
                    }
                };
            });
            stepsDiv.querySelectorAll('.temp-input').forEach(el => {
                el.onchange = function () { updateStep(this.dataset.index, 'temperature', this.value); };
            });
            stepsDiv.querySelectorAll('.on-checkbox').forEach(el => {
                el.onchange = function () { updateStep(this.dataset.index, 'on', this.checked); };
            });
            stepsDiv.querySelectorAll('.del-btn').forEach(el => {
                el.onclick = function () { removeStep(this.dataset.index); };
            });
        }
        function openColorPicker(i) {
            currentColorStep = i;
            whiteSliderStep = null;
            const step = sequence[i];
            document.getElementById('colorPickerModal').style.display = 'block';
            // Store original color for cancel
            window._originalColor = { h: step.hue, s: step.saturation, v: step.brightness };
            // Live preview: update preview color on picker change, but do not update sequence
            async function updateLivePreview() {
                renderSteps();
                console.log('color:change', liveSyncEnabled, window.iroPicker.color);
                if (liveSyncEnabled) {
                    const color = window.iroPicker.color;
                    await fetch('/bulb/color', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            hue: color.hue,
                            saturation: Math.round(color.saturation * 2.55),
                            brightness: Math.round(color.value * 2.55)
                        })
                    });
                }
            }
            function setupPicker() {
                const h = step.hue || 0;
                const s = ((step.saturation || 0) / 255) * 100;
                const v = ((step.brightness || 0) / 255) * 100;
                if (!window.iroPicker) {
                    window.iroPicker = new window.iro.ColorPicker('#colorPicker', {
                        width: 250,
                        color: { h, s, v },
                        layout: [
                            { component: window.iro.ui.Wheel },
                            { component: window.iro.ui.Slider, options: { sliderType: 'value' } }
                        ]
                    });
                    window.iroPicker.on('color:change', updateLivePreview);
                } else {
                    window.iroPicker.color.hue = h;
                    window.iroPicker.color.saturation = s;
                    window.iroPicker.color.value = v;
                    window.iroPicker.off('color:change', updateLivePreview);
                    window.iroPicker.on('color:change', updateLivePreview);
                }
            }
            if (typeof window.iro === 'undefined') {
                const checkIro = setInterval(() => {
                    if (typeof window.iro !== 'undefined') {
                        clearInterval(checkIro);
                        setupPicker();
                    }
                }, 50);
            } else {
                setupPicker();
            }
            // Set up Apply/Cancel buttons
            setTimeout(() => {
                document.getElementById('applyColorBtn').onclick = function (e) {
                    e.preventDefault();
                    if (currentColorStep !== null) {
                        const color = window.iroPicker.color;
                        sequence[currentColorStep].hue = color.hue;
                        sequence[currentColorStep].saturation = Math.round(color.saturation * 2.55);
                        sequence[currentColorStep].brightness = Math.round(color.value * 2.55);
                        renderSteps();
                    }
                    closeColorPicker();
                };
                document.getElementById('cancelColorBtn').onclick = function (e) {
                    e.preventDefault();
                    if (currentColorStep !== null && window._originalColor) {
                        sequence[currentColorStep].hue = window._originalColor.h;
                        sequence[currentColorStep].saturation = window._originalColor.s;
                        sequence[currentColorStep].brightness = window._originalColor.v;
                    }
                    closeColorPicker();
                    renderSteps();
                };
            }, 0);
        }
        function closeColorPicker() {
            document.getElementById('colorPickerModal').style.display = 'none';
            currentColorStep = null;
        }
        function updateStep(i, key, value, skipRender) {
            if (key === 'on') value = value ? true : false;
            else value = key === 'work_mode' ? value : Number(value);
            sequence[i][key] = value;
            renderSteps();
        }
        function removeStep(i) {
            sequence.splice(i, 1);
            renderSteps();
        }
        function hsvToRgb(h, s, v) {
            s /= 255; v /= 255;
            let c = v * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = v - c;
            let r = 0, g = 0, b = 0;
            if (h < 60) { r = c; g = x; } else if (h < 120) { r = x; g = c; } else if (h < 180) { g = c; b = x; } else if (h < 240) { g = x; b = c; } else if (h < 300) { r = x; b = c; } else { r = c; b = x; }
            r = Math.round((r + m) * 255); g = Math.round((g + m) * 255); b = Math.round((b + m) * 255);
            return 'rgb(' + r + ',' + g + ',' + b + ')';
        }
        async function saveSequence() {
            const startTime = document.getElementById('startTime').value;
            const duration = Number(document.getElementById('duration').value);
            const payload = {
                steps: sequence,
                startTime,
                duration
            };
            const res = await fetch('/save-sequence', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            document.getElementById('result').innerText = await res.text();
        }
    </script>
</body>

</html>